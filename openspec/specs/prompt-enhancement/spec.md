# prompt-enhancement Specification

## Purpose
TBD - created by archiving change build-ai-hallucination-reducer-ui. Update Purpose after archive.
## Requirements
### Requirement: Prompt Enhancement Logic

The application MUST support two distinct prompt enhancement modes: static prefix (common sense) and AI-powered (DeepSeek optimization).

**Acceptance Criteria:**
- **Common Sense Mode (Static):**
  - Prefix: "你是专家 " (with trailing space)
  - Suffix: " 请提供主要观点的3个不同出处的网页链接以便我查验。如果你不知道或查不到,就实说,不要编造"
  - Format: `{prefix}{userPrompt}{suffix}`
  - Triggered by "查询常识" button
  - No external API calls
  - Instant response (synchronous)

- **AI-Powered Mode (DeepSeek):**
  - Prefix: Dynamically generated by DeepSeek API (domain-specific expert)
  - Suffix: Same as common sense mode
  - Format: `{dynamicPrefix} {optimizedPrompt}{suffix}`
  - Triggered by "应对未知与复杂" button
  - Calls `/api/optimize` endpoint
  - Async response (1-5 seconds)
  - Includes fluency and punctuation optimization

- **Shared Behavior:**
  - Both modes use identical suffix text
  - Both modes validate input (no empty/whitespace prompts)
  - Both modes clear textarea after success
  - Both modes append to same output area (with visual distinction)

#### Scenario: User Uses Common Sense Mode

**Given** the user enters prompt "什么是机器学习"
**When** the user clicks the "查询常识" button
**Then** the enhanced prompt is generated instantly with static prefix
**And** the result is: "你是专家 什么是机器学习 请提供主要观点的3个不同出处的网页链接以便我查验。如果你不知道或查不到,就实说,不要编造"
**And** no API call is made
**And** the prompt is displayed with orange border and "常识" badge

#### Scenario: User Uses AI-Powered Mode

**Given** the user enters prompt "请问氛围编程这个提法是谁在什么时候提出的"
**When** the user clicks the "应对未知与复杂" button
**Then** an API call is made to `/api/optimize`
**And** the DeepSeek API analyzes the prompt domain
**And** a domain-specific prefix is generated (e.g., "你是 AI 辅助软件开发专家")
**And** the optimized result includes the dynamic prefix and improved punctuation
**And** the prompt is displayed with blue/purple border and "AI优化" badge

#### Scenario: User Alternates Between Modes

**Given** the user has generated 2 prompts using "查询常识"
**And** then generates 1 prompt using "应对未知与复杂"
**And** then generates 1 more using "查询常识"
**When** viewing the output area
**Then** all 4 prompts are displayed in chronological order
**And** prompts 1, 2, 4 show orange border and "常识" badge
**And** prompt 3 shows blue/purple border and "AI优化" badge
**And** the visual distinction is immediately clear

---

### Requirement: Input Validation

The application MUST validate user input before generating enhanced prompts and handle empty or invalid inputs gracefully.

**Acceptance Criteria:**
- Empty input (zero characters) triggers no action
- Whitespace-only input (spaces, tabs, newlines) triggers no action
- Valid input (any non-whitespace characters) triggers enhancement
- No error messages are displayed for invalid input (silent validation)
- Button click with invalid input has no visible effect

#### Scenario: User Clicks Button with Empty Input

**Given** the textarea is completely empty
**When** the user clicks the "查询常识" button
**Then** no enhanced prompt is generated
**And** the output area remains unchanged
**And** the textarea remains empty
**And** no error message is displayed

#### Scenario: User Clicks Button with Whitespace-Only Input

**Given** the textarea contains only spaces and newlines "   \n  "
**When** the user clicks the "查询常识" button
**Then** no enhanced prompt is generated
**And** the output area remains unchanged
**And** the textarea content is not cleared
**And** no error message is displayed

#### Scenario: User Enters Valid Input After Failed Attempt

**Given** the user previously clicked the button with empty input
**And** no action occurred
**When** the user types "机器学习" in the textarea
**And** clicks the button again
**Then** the enhanced prompt is generated successfully
**And** the prompt is added to the output area

---

### Requirement: Input Clearing After Enhancement

The application MUST automatically clear the input textarea immediately after successfully generating an enhanced prompt.

**Acceptance Criteria:**
- Textarea is cleared (set to empty string) after enhancement
- Clearing occurs within the same button click handler
- Clearing happens before scroll animation completes
- User can immediately begin typing a new prompt
- Textarea placeholder text reappears after clearing

#### Scenario: User Generates Enhancement and Continues

**Given** the textarea contains "什么是深度学习"
**When** the user clicks the "查询常识" button
**Then** the enhanced prompt is added to the output area
**And** the textarea is immediately cleared (empty string)
**And** the placeholder text reappears in the textarea
**When** the user starts typing a new prompt
**Then** the new text appears without any residual content

#### Scenario: Rapid Consecutive Enhancements

**Given** the textarea contains "第一个问题"
**When** the user clicks the button
**And** immediately types "第二个问题" (without waiting for animations)
**And** clicks the button again
**Then** two separate enhanced prompts are generated
**And** each enhancement uses the correct corresponding input
**And** the textarea is empty after both operations

---

### Requirement: Enhanced Prompt Storage and Display

The application MUST store all enhanced prompts (from both modes) in chronological order with metadata indicating the enhancement type.

**Acceptance Criteria:**
- Prompts are stored with type: `'static' | 'ai-powered'`
- Data structure: `Array<{text: string, type: 'static' | 'ai-powered', timestamp?: number}>`
- Both types are appended to the same array in order
- Display shows visual distinction based on type
- No limit on number of prompts (within browser memory)

#### Scenario: Storage Includes Enhancement Type

**Given** the user generates a static prompt and an AI-powered prompt
**When** viewing the React state
**Then** the state array contains:
```javascript
[
  {text: "你是专家 什么是机器学习...", type: "static"},
  {text: "你是 AI 辅助软件开发专家 请问氛围编程...", type: "ai-powered"}
]
```

#### Scenario: Display Differentiates by Type

**Given** the output area contains prompts of both types
**When** rendering the prompts
**Then** each prompt's visual style is determined by its `type` property
**And** static prompts show orange theme
**And** AI-powered prompts show blue/purple theme

---

### Requirement: Automatic Scroll to Latest Prompt

The application MUST automatically scroll the output area to display the newest enhanced prompt when it is generated.

**Acceptance Criteria:**
- Output area scrolls to bottom when new prompt is added
- Scroll animation is smooth (not instant jump)
- Scroll duration is 200-500ms for good UX
- Scroll occurs after the prompt is added to the DOM
- User can still manually scroll during/after automatic scroll

#### Scenario: Output Area is Not Scrollable

**Given** the output area contains 2 prompts
**And** the total height does not exceed max-height (no scrollbar)
**When** the user generates a 3rd prompt
**Then** the prompt appears at the bottom
**And** no scroll animation occurs (not needed)
**And** all three prompts remain visible

#### Scenario: Output Area Requires Scrolling

**Given** the output area contains 8 prompts
**And** the total height exceeds max-height (scrollbar visible)
**And** the user has scrolled to the top to review old prompts
**When** the user generates a 9th prompt
**Then** the output area smoothly scrolls to the bottom
**And** the newest prompt becomes visible
**And** the scroll animation takes approximately 300ms
**And** older prompts scroll out of view at the top

#### Scenario: User Manually Scrolls During Auto-Scroll

**Given** the system is performing an auto-scroll animation
**When** the user manually grabs the scrollbar or uses scroll wheel
**Then** the manual scroll overrides the automatic scroll
**And** the user maintains full control of the scroll position

---

### Requirement: State Management and Reactivity

The application MUST use React state to manage input and output data reactively.

**Acceptance Criteria:**
- Input prompt is stored in React state (`useState`)
- Enhanced prompts array is stored in React state (`useState`)
- State updates trigger automatic re-renders
- Input field value is controlled by state (two-way binding)
- Output area content is derived from state array
- No direct DOM manipulation for state updates

#### Scenario: User Types in Textarea

**Given** the textarea is empty
**When** the user types "机器学习"
**Then** the React state `inputPrompt` updates on each keystroke
**And** the textarea value reflects the current state
**And** the component re-renders efficiently (React optimization)

#### Scenario: Button Click Updates State

**Given** the textarea contains "深度学习"
**When** the user clicks the "查询常识" button
**Then** the `handleEnhance` function is called
**And** a new enhanced prompt is added to the `enhancedPrompts` state array
**And** the `inputPrompt` state is set to empty string
**And** React re-renders the component
**And** the UI reflects the new state (new prompt visible, input cleared)

---

